/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package velero.annotations.controller;

import io.kubernetes.client.ApiClient;
import io.kubernetes.client.ApiException;
import io.kubernetes.client.Configuration;
import io.kubernetes.client.apis.CoreV1Api;
import io.kubernetes.client.custom.V1Patch;
import io.kubernetes.client.extended.controller.Controller;
import io.kubernetes.client.extended.controller.ControllerManager;
import io.kubernetes.client.extended.controller.LeaderElectingController;
import io.kubernetes.client.extended.controller.builder.ControllerBuilder;
import io.kubernetes.client.extended.controller.reconciler.Reconciler;
import io.kubernetes.client.extended.controller.reconciler.Request;
import io.kubernetes.client.extended.controller.reconciler.Result;
import io.kubernetes.client.extended.leaderelection.LeaderElectionConfig;
import io.kubernetes.client.extended.leaderelection.LeaderElector;
import io.kubernetes.client.extended.leaderelection.resourcelock.EndpointsLock;
import io.kubernetes.client.informer.SharedIndexInformer;
import io.kubernetes.client.informer.SharedInformerFactory;
import io.kubernetes.client.informer.cache.Lister;
import io.kubernetes.client.models.V1Pod;
import io.kubernetes.client.models.V1PodList;
import io.kubernetes.client.models.V1Volume;
import io.kubernetes.client.util.CallGeneratorParams;
import io.kubernetes.client.util.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.IOException;
import java.time.Duration;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class ControllerApp {
    private static final String VELERO_ANNOTATION = "backup.velero.io/backup-volumes";
    private static final String VELERO_ANNOTATION_SANITIZED = "backup.velero.io~1backup-volumes";
    private static final String NS_FILTER_ENV_VAR_NAME = "VELERO_ANNOTATIONS_CONTROLLER_NS_FILTER";

    private static final Logger LOGGER = LoggerFactory.getLogger(ControllerApp.class);

    public static void main(String[] args) throws IOException {
        ApiClient apiClient = Config.defaultClient();
        apiClient.getHttpClient().setReadTimeout(0, TimeUnit.SECONDS);
        Configuration.setDefaultApiClient(apiClient);

        CoreV1Api coreV1Api = new CoreV1Api();

        SharedInformerFactory informerFactory = new SharedInformerFactory();
        SharedIndexInformer<V1Pod> podInformer = informerFactory.sharedIndexInformerFor(
                (CallGeneratorParams params) ->
                        coreV1Api.listPodForAllNamespacesCall(
                                null, null, null, null, null,
                                params.resourceVersion, params.timeoutSeconds, params.watch, null, null),
                V1Pod.class,
                V1PodList.class);

        informerFactory.startAllRegisteredInformers();

        String namespacesFilterStr = System.getenv(NS_FILTER_ENV_VAR_NAME);
        List<String> namespacesFilter;
        if (namespacesFilterStr != null && !namespacesFilterStr.isEmpty()) {
            namespacesFilter = Arrays.asList(namespacesFilterStr.split(","));
            LOGGER.info("Environment variable {} is set, the controller will watch only following namespaces: {}", NS_FILTER_ENV_VAR_NAME, namespacesFilter);
        } else {
            namespacesFilter = null;
        }

        PodVeleroAnnotationsReconciler podReconciler = new PodVeleroAnnotationsReconciler(podInformer, coreV1Api, namespacesFilter);

        Controller controller = ControllerBuilder.defaultBuilder(informerFactory)
                .watch(workQueue -> ControllerBuilder.controllerWatchBuilder(V1Pod.class, workQueue)
                        .withOnDeleteFilter((V1Pod deletedNode, Boolean stateUnknown) -> false)
                        .build())
                .withReconciler(podReconciler)
                .withName("pod-velero-annotations-controller")
                .withReadyFunc(podInformer::hasSynced)
                .build();

        ControllerManager controllerManager = ControllerBuilder.controllerManagerBuilder(informerFactory)
                .addController(controller)
                .build();

        LeaderElectingController leaderElectingController = new LeaderElectingController(
                new LeaderElector(
                        new LeaderElectionConfig(
                                new EndpointsLock("kube-system", "leader-election", "velero-annotations-controller"),
                                Duration.ofMillis(10000),
                                Duration.ofMillis(8000),
                                Duration.ofMillis(5000))),
                controllerManager
        );

        LOGGER.info("Starting controller");
        leaderElectingController.run();
    }

    static class PodVeleroAnnotationsReconciler implements Reconciler {
        private final Lister<V1Pod> podLister;
        private final CoreV1Api coreV1Api;
        private final List<String> namespacesFilter;

        public PodVeleroAnnotationsReconciler(
                SharedIndexInformer<V1Pod> podInformer,
                CoreV1Api coreV1Api,
                @Nullable List<String> namespacesFilter) {
            this.podLister = new Lister<>(podInformer.getIndexer());
            this.coreV1Api = coreV1Api;
            this.namespacesFilter = namespacesFilter;
        }

        @Override
        public Result reconcile(Request request) {
            if (namespacesFilter != null && !namespacesFilter.contains(request.getNamespace())) {
                LOGGER.debug(
                        "Skip reconciliation in namespace {} since namespacesFilter is set, and {} is not part of it.",
                        request.getNamespace(), request.getNamespace());
                return new Result(false);
            }

            V1Pod pod = this.podLister.namespace(request.getNamespace()).get(request.getName());

            Map<String, String> podAnnotations = pod.getMetadata().getAnnotations();
            String veleroAnnotationValuesStr = podAnnotations.get(VELERO_ANNOTATION);
            List<String> veleroAnnotationValues;
            if (veleroAnnotationValuesStr == null) {
                veleroAnnotationValues = Collections.emptyList();
            } else {
                veleroAnnotationValues = Arrays.asList(veleroAnnotationValuesStr.split(","));
                Collections.sort(veleroAnnotationValues);
            }

            List<String> persistentVolumes = pod.getSpec().getVolumes().stream()
                    .filter(volume -> volume.getPersistentVolumeClaim() != null)
                    .map(V1Volume::getName)
                    .sorted()
                    .collect(Collectors.toList());

            if (veleroAnnotationValues.isEmpty() && persistentVolumes.isEmpty()) {
                return new Result(false);
            }

            if (!veleroAnnotationValues.equals(persistentVolumes)) {
                LOGGER.info("Reconciling pod {}/{}: veleroAnnotation='{}', persistentVolumes='{}'", request.getNamespace(), request.getName(), veleroAnnotationValues, persistentVolumes);
                String patch;

                if (persistentVolumes.isEmpty()) {
                    patch = "[{\"op\":\"remove\",\"path\":\"/metadata/annotations/" + VELERO_ANNOTATION_SANITIZED + "\"}]";
                } else {
                    String action = veleroAnnotationValues.isEmpty() ? "add" : "replace";
                    String value = String.join(",", persistentVolumes);
                    patch = "[{\"op\":\"" + action + "\",\"path\":\"/metadata/annotations/" + VELERO_ANNOTATION_SANITIZED + "\",\"value\":\"" + value + "\"}]";
                }

                try {
                    coreV1Api.patchNamespacedPod(request.getName(), request.getNamespace(), new V1Patch(patch), null, null, null, null);
                } catch (ApiException e) {
                    LOGGER.error("Exception occurred while patching the pod {}/{} with patch {}.", request.getNamespace(), request.getName(), patch, e);
                    new Result(true);
                }

            }

            return new Result(false);
        }
    }
}
